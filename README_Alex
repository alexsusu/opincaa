Note that we have 2 methods that basically do the same thing:
    - connexGlobal->dumpKernel() - it outputs in C++ Opincaa format ASM instructions
    - connexGlobal->disassembleKernel() - it outputs in Connex ASM format

A few things should be parametrized:
    - maybe Multiplication - can be signed OR UNsigned
    - Reduction - can be signed OR UNsigned


If you get cryptic error message when compiling an Opincaa module like:
    <<output.cpp:91:10: error: macro "EXECUTE_IN_ALL" passed 3 arguments, but takes just 1>>
  you should build that module with gcc -E and look in the output_main.cpp where is the error actually coming from.
  For example, I got this error because I used:
    CELL_SHL R0, R1;
  and the correct syntax is:
    CELL_SHL ( R0, R1 );
NOTE: Currently the cryptic error messages (no clear line, no clear statement, but just the enclosing EXECUTE*() macro)
  are given by the EXECUTE*() macros that hold instructions inside (they take a list of instructions as parameter) - this seems to be a problem of GCC's preprocessor.

  un exemplu fara ele, in care primim erori clare la compilare (numar linie si continut linie) la  ~/Connex/OPINCAA_2015_10/opincaa-master-d49993900aaf33580858c74e090a77bd67217702/111BUG/2Propose/How_to_get_nice_error_messages_in_Opincaa_modules_by_avoiding_EXECUTE_macrodefs

To add a new instruction to Opincaa simulator you need to edit the following files and add:
    - in arch/connex16-hm-generic/include/Instruction.h
        // Alex: for debug support - opcode of _PRINT_REG instruction
        // PRINT_REG takes a register as operand --> has type INSTRUCTION_TYPE_NO_VALUE, and this means that we need to put an opcode "close" to REDUCE
        #define _PRINT_REG  0x101

        // PRINT_REG takes an immediate value as operand --> has type INSTRUCTION_TYPE_WITH_VALUE, and this means that we need to put an opcode "close" to SETLC
        #define _PRINT_CHARS  0x14

        // Experimental: #define _SETLC_REDUCE 0x102
        // Experimental: #define _BIT_REVERSE 0x14D

        a value of 1 in:
            type_for_opcode, at 257 (0x101, the opcode)
            type_for_opcode, at 258 (0x102, the opcode)
        a value of 2 in:
            type_for_opcode, at 20 (0x14, the opcode)
        NOTE: for type_for_opcode we put 1 if we have instruction like REDUCE, ADD, etc (INSTRUCTION_TYPE_NO_VALUE) and 2 if we have like SETLC (INSTRUCTION_TYPE_WITH_VALUE).


    - in arch/connex16-hm-generic/src/Instruction.cpp (we provide example ONLY for _PRINT_REG):
        string Instruction::mnemonic(int opcode) {
            case _PRINT_REG: return string("print_reg"); // Alex

        string Instruction::disassemble() {
            case _PRINT_REG: // Alex

        string Instruction::dump()
            case _PRINT_REG: stream << "print_reg" << registerName(left); break; // Alex


    - in include/Kernel.h
        #define PRINTREG(regIndex)          __kernel->append(Instruction(_PRINT_REG, 0, regIndex, 0));
        #define PRINTCHARS(value)           __kernel->append(Instruction(_PRINT_CHARS, value, 0, 0));


        // Experimental: #define BITREVERSE(regIndex)          __kernel->append(Instruction(_BIT_REVERSE, 0, regIndex, 0));


        #define REPEAT_REDUCE(regIndex)     __kernel->append(Instruction(_SETLC_REDUCE, 0, regIndex, 0)); \
                                            __kernel->resetLoopDestination(); // IMPORTANT NOTE: we require to add __kernel->resetLoopDestination() for the loop (i.e., IJMPNZDEC) to work well


    - in src/ConnexSimulator.cpp:
        void ConnexSimulator::executeInstruction(Instruction instruction)
            case _PRINT_REG:


    - in core/Operand.cpp we add for the _BIT_REVERSE Instruction (whis is the only instruction we added that returns a result, so far):
        Instruction Operand::bitreverse(Operand op) {
            if(op.type != TYPE_REGISTER) {
                throw string("Invalid operand type for popcnt operator");
            }
            return Instruction(_BIT_REVESE, 0, op.index, 0);
        }
      and in include/Operand.h:
        static Instruction bitreverse(Operand op);


Although somehow it's less intuitive to have blocks
    EXECUTE_*(...);
  instead of WHERE* ... END_WHERE blocks
  I think it's better like this because the paranthesis (...) gives us clear syntax highlight (possibly jump to associated begin/end) in editors like VIM or MCEDIT.

NOTE: Opincaa generates an END_WHERE at the beginning of the kernel - it's mandatory to be there, this is how Connex starts, after reboot, etc start executing vector instructions in ALL lanes.
